{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/2019-07-22-imperative-versus-declarative/","result":{"data":{"markdownRemark":{"id":"22af1cfb-6d68-5966-bf27-5fff5ac1d322","html":"<p>원본: <a href=\"https://medium.com/front-end-weekly/imperative-versus-declarative-code-whats-the-difference-adc7dd6c8380\">imperative-versus-declarative-code-whats-the-difference</a></p>\n<p>위 포스팅을 읽고 요점을 정리한 내용입니다.</p>\n<h3 id=\"명령형-패러다임-imperative\" style=\"position:relative;\"><a href=\"#%EB%AA%85%EB%A0%B9%ED%98%95-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84-imperative\" aria-label=\"명령형 패러다임 imperative permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>명령형 패러다임 (Imperative)</h3>\n<ul>\n<li>\n<p>절차, 객체지향 프로그래밍은 명령형 패러다임 기반.</p>\n<ul>\n<li>C, C++, C#, PHP, Java 같은 언어가 대표적.</li>\n</ul>\n</li>\n<li>프로그램의 상태를 변경하는 내용의 명령문을 작성하는 방식.</li>\n<li>하드웨어의 동작 방식과 밀접한 관계가 있음.</li>\n<li>명령형 패러다임 코드는 조건문, 루프, 상속을 사용.</li>\n</ul>\n<pre>\n<code>\nclass Number {\n  constructor (number = 0) {\n    this.number = number;\n  }\n  \n  add (x) {\n    this.number = this.number + x;\n  }\n}\nconst myNumber = new Number (5);\nmyNumber.add (3);\nconsole.log (myNumber.number); // 8\n\n</code>\n</pre>\n<h3 id=\"선언적-패러다임-declarative\" style=\"position:relative;\"><a href=\"#%EC%84%A0%EC%96%B8%EC%A0%81-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84-declarative\" aria-label=\"선언적 패러다임 declarative permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선언적 패러다임 (Declarative)</h3>\n<ul>\n<li>\n<p>논리, 함수형, 도메인 특정 언어는 선언적 패러다임 기반.</p>\n<ul>\n<li>HTML, XML, CSS, SQL, Prolog, Haskell, F# 같은 언어가 대표적.</li>\n<li>범용적으로 사용되는 프로그래밍 언어가 아닐 수 있음.</li>\n</ul>\n</li>\n<li>\n<p>소프트웨어 흐름을 묘사하는것보다 소프트웨어 로직을 구축하는 것에 중점을 두는 방식.</p>\n<ul>\n<li>예를 들면, <code class=\"language-text\">&lt;img src=&quot;./image.jpg&quot; /&gt;</code>의 경우 브라우저에게 이미지를 표시하라고 말하지만, 어떻게 표시하는지는 정의하지 않음.</li>\n</ul>\n</li>\n<li>람다 계산법 기반으로 상태, 사이드 이펙트, 변할수 있는 데이터를 피함.</li>\n<li>명령문 대신 표현식을 작성.</li>\n<li>같은 데이터가 입력 됐을 경우, 항상 같은 값을 반환하여야 함.</li>\n</ul>\n<pre>\n<code>\nconst sum = a => b => a + b;\nconsole.log (sum (5) (3)); // 8\n\n</code>\n</pre>","fields":{"slug":"/posts/2019-07-22-imperative-versus-declarative/","tagSlugs":["/tag/frontend/"]},"frontmatter":{"date":"2019-07-22T13:00:00.121Z","description":"","tags":["Frontend"],"title":"명령형 패러다임 vs 선언적 패러다임","socialImage":null}}},"pageContext":{"slug":"/posts/2019-07-22-imperative-versus-declarative/"}},"staticQueryHashes":["251939775","401334301","825871152"]}